{"ast":null,"code":"import{useQuery,useQueryClient}from'react-query';import api from'../services/api';// Cache keys for localStorage\nconst PRODUCTS_CACHE_KEY='pos_products_cache';const PRODUCTS_CACHE_TIMESTAMP_KEY='pos_products_cache_timestamp';const CACHE_DURATION=30*60*1000;// 30 minutes\n/**\n * Get cached products from localStorage\n */const getCachedProducts=()=>{try{const cached=localStorage.getItem(PRODUCTS_CACHE_KEY);const timestamp=localStorage.getItem(PRODUCTS_CACHE_TIMESTAMP_KEY);if(cached&&timestamp){const age=Date.now()-parseInt(timestamp,10);if(age<CACHE_DURATION){return JSON.parse(cached);}}}catch(error){console.error('Error reading products cache:',error);}return null;};/**\n * Save products to localStorage cache\n */const saveProductsToCache=products=>{try{localStorage.setItem(PRODUCTS_CACHE_KEY,JSON.stringify(products));localStorage.setItem(PRODUCTS_CACHE_TIMESTAMP_KEY,Date.now().toString());}catch(error){console.error('Error saving products cache:',error);}};/**\n * Enhanced products hook for POS with localStorage persistence\n * @param {Object} filters - Filter parameters (category, is_active, etc.)\n * @returns {Object} Query result with products data\n */export const useProductsPOS=function(){let filters=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};// Get cached data for initial state\nconst cachedProducts=getCachedProducts();const hasValidCache=cachedProducts&&(!filters.category||filters.category==='');return useQuery(['products-pos',filters],async()=>{// Check cache first - if valid and no category filter, return immediately\nconst cached=getCachedProducts();const isValidCache=cached&&(!filters.category||filters.category==='');if(isValidCache){// Still fetch in background to update cache\nfetchFreshProducts(filters).then(products=>{if(products&&(!filters.category||filters.category==='')){saveProductsToCache(products);}}).catch(()=>{// Ignore errors in background fetch\n});return cached;}// Fetch fresh data\nconst products=await fetchFreshProducts(filters);// Save to localStorage when data is fetched (only for all products, not filtered)\nif(products&&(!filters.category||filters.category==='')){saveProductsToCache(products);}return products;},{staleTime:30*60*1000,// 30 minutes - longer cache for POS\ncacheTime:60*60*1000,// 1 hour - keep in memory cache longer\nrefetchOnWindowFocus:false,refetchOnMount:!hasValidCache,// Don't refetch on mount if we have valid cache\nrefetchOnReconnect:true,// Use cached data as initial data if available\ninitialData:hasValidCache?cachedProducts:undefined});};/**\n * Fetch fresh products from API\n */const fetchFreshProducts=async function(){let filters=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};try{const params=new URLSearchParams();// Always filter for active products\nif(filters.is_active!==false){params.append('is_active','true');}// Add category filter if provided\nif(filters.category){params.append('category',filters.category);}const baseUrl=\"/api/products/\".concat(params.toString()?'?'+params.toString():'');let response=await api.get(baseUrl);let aggregatedProducts=Array.isArray(response.data.results)?response.data.results:Array.isArray(response.data)?response.data:[];// Follow pagination to get all products (DRF-style \"next\" links)\nlet nextUrl=response.data.next;while(nextUrl){response=await api.get(nextUrl);const pageItems=Array.isArray(response.data.results)?response.data.results:Array.isArray(response.data)?response.data:[];aggregatedProducts=aggregatedProducts.concat(pageItems);nextUrl=response.data.next;}return aggregatedProducts;}catch(error){console.error('Error fetching products:',error);// Return cached data if fetch fails\nconst cached=getCachedProducts();if(cached){return cached;}throw error;}};/**\n * Clear products cache\n */export const clearProductsCache=()=>{try{localStorage.removeItem(PRODUCTS_CACHE_KEY);localStorage.removeItem(PRODUCTS_CACHE_TIMESTAMP_KEY);}catch(error){console.error('Error clearing products cache:',error);}};","map":{"version":3,"names":["useQuery","useQueryClient","api","PRODUCTS_CACHE_KEY","PRODUCTS_CACHE_TIMESTAMP_KEY","CACHE_DURATION","getCachedProducts","cached","localStorage","getItem","timestamp","age","Date","now","parseInt","JSON","parse","error","console","saveProductsToCache","products","setItem","stringify","toString","useProductsPOS","filters","arguments","length","undefined","cachedProducts","hasValidCache","category","isValidCache","fetchFreshProducts","then","catch","staleTime","cacheTime","refetchOnWindowFocus","refetchOnMount","refetchOnReconnect","initialData","params","URLSearchParams","is_active","append","baseUrl","concat","response","get","aggregatedProducts","Array","isArray","data","results","nextUrl","next","pageItems","clearProductsCache","removeItem"],"sources":["/home/antatsimo/WareHouse_Manager/elif-sales-app/beverage_management_system/src/hooks/useProductsPOS.js"],"sourcesContent":["import { useQuery, useQueryClient } from 'react-query';\nimport api from '../services/api';\n\n// Cache keys for localStorage\nconst PRODUCTS_CACHE_KEY = 'pos_products_cache';\nconst PRODUCTS_CACHE_TIMESTAMP_KEY = 'pos_products_cache_timestamp';\nconst CACHE_DURATION = 30 * 60 * 1000; // 30 minutes\n\n/**\n * Get cached products from localStorage\n */\nconst getCachedProducts = () => {\n  try {\n    const cached = localStorage.getItem(PRODUCTS_CACHE_KEY);\n    const timestamp = localStorage.getItem(PRODUCTS_CACHE_TIMESTAMP_KEY);\n    \n    if (cached && timestamp) {\n      const age = Date.now() - parseInt(timestamp, 10);\n      if (age < CACHE_DURATION) {\n        return JSON.parse(cached);\n      }\n    }\n  } catch (error) {\n    console.error('Error reading products cache:', error);\n  }\n  return null;\n};\n\n/**\n * Save products to localStorage cache\n */\nconst saveProductsToCache = (products) => {\n  try {\n    localStorage.setItem(PRODUCTS_CACHE_KEY, JSON.stringify(products));\n    localStorage.setItem(PRODUCTS_CACHE_TIMESTAMP_KEY, Date.now().toString());\n  } catch (error) {\n    console.error('Error saving products cache:', error);\n  }\n};\n\n/**\n * Enhanced products hook for POS with localStorage persistence\n * @param {Object} filters - Filter parameters (category, is_active, etc.)\n * @returns {Object} Query result with products data\n */\nexport const useProductsPOS = (filters = {}) => {\n  // Get cached data for initial state\n  const cachedProducts = getCachedProducts();\n  const hasValidCache = cachedProducts && (!filters.category || filters.category === '');\n  \n  return useQuery(\n    ['products-pos', filters],\n    async () => {\n      // Check cache first - if valid and no category filter, return immediately\n      const cached = getCachedProducts();\n      const isValidCache = cached && (!filters.category || filters.category === '');\n      \n      if (isValidCache) {\n        // Still fetch in background to update cache\n        fetchFreshProducts(filters).then(products => {\n          if (products && (!filters.category || filters.category === '')) {\n            saveProductsToCache(products);\n          }\n        }).catch(() => {\n          // Ignore errors in background fetch\n        });\n        return cached;\n      }\n      \n      // Fetch fresh data\n      const products = await fetchFreshProducts(filters);\n      \n      // Save to localStorage when data is fetched (only for all products, not filtered)\n      if (products && (!filters.category || filters.category === '')) {\n        saveProductsToCache(products);\n      }\n      \n      return products;\n    },\n    {\n      staleTime: 30 * 60 * 1000, // 30 minutes - longer cache for POS\n      cacheTime: 60 * 60 * 1000, // 1 hour - keep in memory cache longer\n      refetchOnWindowFocus: false,\n      refetchOnMount: !hasValidCache, // Don't refetch on mount if we have valid cache\n      refetchOnReconnect: true,\n      // Use cached data as initial data if available\n      initialData: hasValidCache ? cachedProducts : undefined,\n    }\n  );\n};\n\n/**\n * Fetch fresh products from API\n */\nconst fetchFreshProducts = async (filters = {}) => {\n  try {\n    const params = new URLSearchParams();\n    \n    // Always filter for active products\n    if (filters.is_active !== false) {\n      params.append('is_active', 'true');\n    }\n    \n    // Add category filter if provided\n    if (filters.category) {\n      params.append('category', filters.category);\n    }\n    \n    const baseUrl = `/api/products/${params.toString() ? '?' + params.toString() : ''}`;\n    let response = await api.get(baseUrl);\n    let aggregatedProducts = Array.isArray(response.data.results) \n      ? response.data.results \n      : (Array.isArray(response.data) ? response.data : []);\n    \n    // Follow pagination to get all products (DRF-style \"next\" links)\n    let nextUrl = response.data.next;\n    while (nextUrl) {\n      response = await api.get(nextUrl);\n      const pageItems = Array.isArray(response.data.results) \n        ? response.data.results \n        : (Array.isArray(response.data) ? response.data : []);\n      aggregatedProducts = aggregatedProducts.concat(pageItems);\n      nextUrl = response.data.next;\n    }\n    \n    return aggregatedProducts;\n  } catch (error) {\n    console.error('Error fetching products:', error);\n    // Return cached data if fetch fails\n    const cached = getCachedProducts();\n    if (cached) {\n      return cached;\n    }\n    throw error;\n  }\n};\n\n/**\n * Clear products cache\n */\nexport const clearProductsCache = () => {\n  try {\n    localStorage.removeItem(PRODUCTS_CACHE_KEY);\n    localStorage.removeItem(PRODUCTS_CACHE_TIMESTAMP_KEY);\n  } catch (error) {\n    console.error('Error clearing products cache:', error);\n  }\n};\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}