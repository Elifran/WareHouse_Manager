{"ast":null,"code":"import _objectSpread from\"/home/el-ifran/WareHouse_Manager/elif-sales-app/beverage_management_system/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import{useQuery,useQueryClient}from'react-query';import api from'../services/api';// Cache keys for localStorage\nconst CATEGORIES_CACHE_KEY='pos_categories_cache';const CATEGORIES_CACHE_TIMESTAMP_KEY='pos_categories_cache_timestamp';const CACHE_DURATION=60*60*1000;// 1 hour - categories change very rarely\n/**\n * Get cached categories from localStorage\n */const getCachedCategories=()=>{try{const cached=localStorage.getItem(CATEGORIES_CACHE_KEY);const timestamp=localStorage.getItem(CATEGORIES_CACHE_TIMESTAMP_KEY);if(cached&&timestamp){const age=Date.now()-parseInt(timestamp,10);if(age<CACHE_DURATION){return JSON.parse(cached);}}}catch(error){console.error('Error reading categories cache:',error);}return null;};/**\n * Save categories to localStorage cache\n */const saveCategoriesToCache=categories=>{try{localStorage.setItem(CATEGORIES_CACHE_KEY,JSON.stringify(categories));localStorage.setItem(CATEGORIES_CACHE_TIMESTAMP_KEY,Date.now().toString());}catch(error){console.error('Error saving categories cache:',error);}};/**\n * Enhanced categories hook for POS with localStorage persistence\n * @returns {Object} Query result with categories data\n */export const useCategoriesPOS=()=>{// Get cached data for initial state\nconst cachedCategories=getCachedCategories();const hasValidCache=!!cachedCategories;return useQuery(['categories-pos'],async()=>{// Check cache first - if valid, return immediately\nconst cached=getCachedCategories();if(cached){// Still fetch in background to update cache\nfetchFreshCategories().then(categories=>{if(categories){saveCategoriesToCache(categories);}}).catch(()=>{// Ignore errors in background fetch\n});return cached;}// Fetch fresh data\nconst categories=await fetchFreshCategories();// Save to localStorage when data is fetched\nif(categories){saveCategoriesToCache(categories);}return categories;},{staleTime:60*60*1000,// 1 hour - categories change very rarely\ncacheTime:2*60*60*1000,// 2 hours - keep in memory cache longer\nrefetchOnWindowFocus:false,refetchOnMount:!hasValidCache,// Don't refetch on mount if we have valid cache\nrefetchOnReconnect:true,// Use cached data as initial data if available\ninitialData:hasValidCache?cachedCategories:undefined});};/**\n * Fetch fresh categories from API\n */const fetchFreshCategories=async()=>{try{const response=await api.get('/api/products/categories/');let categoriesData=response.data.results||response.data;// Load session-based sellable status from sessionStorage\nconst sellableStatus=JSON.parse(sessionStorage.getItem('sellableCategories')||'{}');// Apply session-based sellable status\ncategoriesData=categoriesData.map(cat=>{const isSellable=sellableStatus.hasOwnProperty(cat.id)?sellableStatus[cat.id]:cat.is_sellable;return _objectSpread(_objectSpread({},cat),{},{is_sellable:isSellable});});return categoriesData;}catch(error){console.error('Error fetching categories:',error);// Return cached data if fetch fails\nconst cached=getCachedCategories();if(cached){return cached;}throw error;}};/**\n * Clear categories cache\n */export const clearCategoriesCache=()=>{try{localStorage.removeItem(CATEGORIES_CACHE_KEY);localStorage.removeItem(CATEGORIES_CACHE_TIMESTAMP_KEY);}catch(error){console.error('Error clearing categories cache:',error);}};","map":{"version":3,"names":["useQuery","useQueryClient","api","CATEGORIES_CACHE_KEY","CATEGORIES_CACHE_TIMESTAMP_KEY","CACHE_DURATION","getCachedCategories","cached","localStorage","getItem","timestamp","age","Date","now","parseInt","JSON","parse","error","console","saveCategoriesToCache","categories","setItem","stringify","toString","useCategoriesPOS","cachedCategories","hasValidCache","fetchFreshCategories","then","catch","staleTime","cacheTime","refetchOnWindowFocus","refetchOnMount","refetchOnReconnect","initialData","undefined","response","get","categoriesData","data","results","sellableStatus","sessionStorage","map","cat","isSellable","hasOwnProperty","id","is_sellable","_objectSpread","clearCategoriesCache","removeItem"],"sources":["/home/el-ifran/WareHouse_Manager/elif-sales-app/beverage_management_system/src/hooks/useCategoriesPOS.js"],"sourcesContent":["import { useQuery, useQueryClient } from 'react-query';\nimport api from '../services/api';\n\n// Cache keys for localStorage\nconst CATEGORIES_CACHE_KEY = 'pos_categories_cache';\nconst CATEGORIES_CACHE_TIMESTAMP_KEY = 'pos_categories_cache_timestamp';\nconst CACHE_DURATION = 60 * 60 * 1000; // 1 hour - categories change very rarely\n\n/**\n * Get cached categories from localStorage\n */\nconst getCachedCategories = () => {\n  try {\n    const cached = localStorage.getItem(CATEGORIES_CACHE_KEY);\n    const timestamp = localStorage.getItem(CATEGORIES_CACHE_TIMESTAMP_KEY);\n    \n    if (cached && timestamp) {\n      const age = Date.now() - parseInt(timestamp, 10);\n      if (age < CACHE_DURATION) {\n        return JSON.parse(cached);\n      }\n    }\n  } catch (error) {\n    console.error('Error reading categories cache:', error);\n  }\n  return null;\n};\n\n/**\n * Save categories to localStorage cache\n */\nconst saveCategoriesToCache = (categories) => {\n  try {\n    localStorage.setItem(CATEGORIES_CACHE_KEY, JSON.stringify(categories));\n    localStorage.setItem(CATEGORIES_CACHE_TIMESTAMP_KEY, Date.now().toString());\n  } catch (error) {\n    console.error('Error saving categories cache:', error);\n  }\n};\n\n/**\n * Enhanced categories hook for POS with localStorage persistence\n * @returns {Object} Query result with categories data\n */\nexport const useCategoriesPOS = () => {\n  // Get cached data for initial state\n  const cachedCategories = getCachedCategories();\n  const hasValidCache = !!cachedCategories;\n  \n  return useQuery(\n    ['categories-pos'],\n    async () => {\n      // Check cache first - if valid, return immediately\n      const cached = getCachedCategories();\n      if (cached) {\n        // Still fetch in background to update cache\n        fetchFreshCategories().then(categories => {\n          if (categories) {\n            saveCategoriesToCache(categories);\n          }\n        }).catch(() => {\n          // Ignore errors in background fetch\n        });\n        return cached;\n      }\n      \n      // Fetch fresh data\n      const categories = await fetchFreshCategories();\n      \n      // Save to localStorage when data is fetched\n      if (categories) {\n        saveCategoriesToCache(categories);\n      }\n      \n      return categories;\n    },\n    {\n      staleTime: 60 * 60 * 1000, // 1 hour - categories change very rarely\n      cacheTime: 2 * 60 * 60 * 1000, // 2 hours - keep in memory cache longer\n      refetchOnWindowFocus: false,\n      refetchOnMount: !hasValidCache, // Don't refetch on mount if we have valid cache\n      refetchOnReconnect: true,\n      // Use cached data as initial data if available\n      initialData: hasValidCache ? cachedCategories : undefined,\n    }\n  );\n};\n\n/**\n * Fetch fresh categories from API\n */\nconst fetchFreshCategories = async () => {\n  try {\n    const response = await api.get('/api/products/categories/');\n    let categoriesData = response.data.results || response.data;\n    \n    // Load session-based sellable status from sessionStorage\n    const sellableStatus = JSON.parse(sessionStorage.getItem('sellableCategories') || '{}');\n    \n    // Apply session-based sellable status\n    categoriesData = categoriesData.map(cat => {\n      const isSellable = sellableStatus.hasOwnProperty(cat.id) \n        ? sellableStatus[cat.id] \n        : cat.is_sellable;\n      return {\n        ...cat,\n        is_sellable: isSellable\n      };\n    });\n    \n    return categoriesData;\n  } catch (error) {\n    console.error('Error fetching categories:', error);\n    // Return cached data if fetch fails\n    const cached = getCachedCategories();\n    if (cached) {\n      return cached;\n    }\n    throw error;\n  }\n};\n\n/**\n * Clear categories cache\n */\nexport const clearCategoriesCache = () => {\n  try {\n    localStorage.removeItem(CATEGORIES_CACHE_KEY);\n    localStorage.removeItem(CATEGORIES_CACHE_TIMESTAMP_KEY);\n  } catch (error) {\n    console.error('Error clearing categories cache:', error);\n  }\n};\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}